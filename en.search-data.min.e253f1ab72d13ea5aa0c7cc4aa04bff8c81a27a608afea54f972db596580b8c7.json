[{"id":0,"href":"/docs/archive/Nihongo/39%E8%AA%B2/","title":"39課","section":"Nihongo","content":" 単語 # いね　稲\nきり　霧\n霧がかかっている。 もん　門\nぶたい　舞台\nやね　屋根　屋顶\nるりがわら　瑠璃瓦\nきいろ　黄色\nバック　back　背景\nこの建物をバックにして、写真を撮ってもらいませんか。 かしきり　貸切　包租\n貸切バス 貸切温泉 いっぱん　一般\nそぼ　祖母\nジャズ　jazz\nやがい　野外コンサート　露天音乐会\nえんだか　円高　日元升值\n円安　日元贬值 ゆしゅつ　輸出　出口、输出\nゆにゅう　輸入 えいきょう　影響\nしげん　資源\n資源が豊かです。　ゆたか　豊か きおん　気温\n気温が高い／低い。　ひくい　低い おき　沖　海上、湖心\nおきなわ　沖縄 かいがい　海外\nクジラ　鯨\nサメ　鮫　鲨鱼\nむかし　昔\nべつめい　別名\nほう　方　方面\nどうろこうじ　道路工事\n通勤ラッシュ　つうきんrush　上下班高峰\nつうこうきんし　通行禁止\nとおく　遠く\n霧がかかっているから、遠くまでがはっきり見えません。 みわたす　見渡す　眺望、远望\n山を見渡す。 つづく　続く\n円高が続く。 なくなる　無くなる　完、丢失\nお金が無くなった。 財布が無くなった。 そだつ　育つ　生长、成长\n稲が育ちます。 ふえる　増える\n交通事故が増えました。 つれる　連れる　带、领（人或动物）\n子供をつれる。 けっせきする　欠席する　缺席\n会議を欠席する。 ゆにゅうする　輸入する\nリットル　升\nせっかく\nせっかく北京に来て、必ず万里の長城へ行きます。 文法 # ～て～　／　～ないで（ずに／せずに）～　伴随前项的动作进行后项动作 # 眼鏡をかけて本を読む。 上を向いて歩こう。　むいて　向いて 帽子をかぶって出かけた。 今日荷物がないので、歩いて帰ります。 息子は今朝、ご飯を食べないで出かけた。 息子は今朝、ご飯を食べずに出かけた。 予約しないで行ったら、満席で入れなかった。 予約せずに行ったら、満席で入れなかった。 歯を磨かないで寝てはいけません。　は　歯　みがく　磨く 歯を磨かずに寝てはいけません。 小句简体/形2な/名词の　＋　ために、～　前项是后项原因，书面，更多用于不情愿的事情的原因 # 台風が近づいているために波が高くなっている。　なみ　波 由于台风接近，风浪很大 去年の夏は気温が低かったために、米は不作だった。　ひくかった　低かった　こめ　米　ふさく　不作 事故のために現在5キロの渋滞です。 ～ていく／～てくる # 疲れているんでしょう、ちょっと休んでいきなさい。 夜は寒いから、熱いものを食べていきましょう。 傘を電車の中に忘れてきた。 子供を連れていきます。 お弁当を持ってきてください。 夜は寒いから、コートを着ていきましょう。 夜里冷，穿着大衣去吧。 船は離れていく。　ふね　船　はなれる　離れる 船离我远去。 たくさんの人が乗ってきましたね。 好多人上来。 たくさんの人が乗っていきましたね。 好多人上去。 子供はお母さんのところへ走っていきます。 ちょっと出かけてきます。 我去一下就回。 この手紙を出してきます。 手を洗ってきます。 "},{"id":1,"href":"/docs/archive/Nihongo/38%E8%AA%B2/","title":"38課","section":"Nihongo","content":" 単語 # しょうひん　商品\nごみばこ　ゴミ箱垃圾箱\nコップ　kop（荷兰语）　杯子\nペットボトル　pet bottle　塑料瓶\nエンジン　engine　引擎\nタイヤ　tire　轮胎\nフートン　胡同　胡同\nろじ　路地　小巷、弄堂\nにほんしょく　日本食\nさしみ　刺身\nたな　棚　橱柜\nたたみ　畳　草垫、榻榻米\nきもの　着物　和服\nぐあい　具合　情况、状况\n体の具合がいい／悪い。 ひらがな　平仮名\nカタカナ　片仮名\nあかちゃん　赤ちゃん　婴儿\nはんぶん　半分　一半\nさいしゅう　最終\n試合\nえいじしんぶん　英字新聞\nえいせいほうそう　衛星放送　卫星广播\nストレス　stress　精神紧张状态\nかいしょうほう　解消法\nストレス解消法 いりくむ　入り組む　错综复杂\n入り組んでいる。 この道は入り組んでいますね。 話が入り組んでいて、半分ぐらいしか分かりませんでした。 へる　減る\nうごかす　動かす　开动、移动\n体をうごかす。　锻炼身体 かつ　勝つ　取胜\n試合に勝つ／負ける。　まける とおりぬける　通り抜ける　走得出去、穿过\n感じる\n痛みを感じる。 苦痛を感じる。　くつう　苦痛 取り替える\nこの服がちょっと小さいので、取り替えてくださいませんか。 てつやする　徹夜する　熬夜\nやけどする　火傷する　烫伤、烧伤\nなんだか　何だか　总觉得、总有点\n何だか残念です。 何だか嬉しいです。 この道、暗くて、何だか怖いです。 でんとうてき　伝統的\nこのへん　この辺\nいそいで　急いで　急ぐ\n文法 # ～ように、～ # みんなに聞こえるように、大きな声で話してください。 見えるように、大きく書きました。 転ばないように、ゆっくり歩きましょう。　ころばない　転ばない 家族が心配しないように、手紙を書きます。 オリンピックに参加できるように、毎日練習している。 いつでも出られるように、準備してあります。 お年寄りも使えるように、操作が簡単になっています。 子供が触れないように、この薬は棚の一番上に置きました。 タバコを買えないように、お金を隠した。　かくす　隠す コピーできないように、コピー機を壊した。 留学のために、お金を貯める。 留学に行くために、貯金している。 留学に行けるように、貯金している。 ようになる # けがが治って、歩けるようになりました。　なおる　治る 着物を自分で着られるようになりました。 年を取ると、小さい字が読めなくなります。 太りましたから、好きな服が着られなくなりました。 日本食には慣れましたから、刺身も食べるようになった。 最近、中村さんはお酒を飲むようになりました。 アメリカに来てから、私はあまり中国語を話さなくなりました。 車を買ってから、私はあまりバスに乗らなくなりました。 ようにする # のどが痛いので、今日はあまり話さないようにします。 健康のために、徹夜しないようにします。 陳さんは毎日、英字新聞を読むようにしています。 けんこうのために、油ものは食べないようにします。　あぶら　油 毎朝、7時に起きるようにしています。 もっと野菜を食べるようにしてください。 仕事を休む時に、必ず連絡するようにしてください。 暗い光の下で、できるだけ本を読まないようにしてください。 "},{"id":2,"href":"/docs/archive/Nihongo/37%E8%AA%B2/","title":"37課","section":"Nihongo","content":" 単語 # ようじ　用事 たいかい　大会 きぼ　規模 けいかく　計画 きそく　規則 ひよう　費用 しお　塩 メダル　medal ソフト　software　アプリ　app はんにん　犯人 たんい　単位　计量单位、学分 ばんごうふだ　番号札　顺序条、号码条 こさじ　小さじ　小勺 ボリューム　volume ちょくつうれっしゃ　直通列車 せかいいさん　世界遺産 かんこう　観光スポット　spot こえる　超える しゅつじょうする　出場する しゃくほうする　釈放する つまみぐいする　つまみ食いする　偷吃 ふくしゅうする　よしゅうする　復習　予習 せいこう　しっぱい　成功　失敗 ぜいたく　贅沢　奢侈 贅沢な生活 こっそり　偷偷地、悄悄地 さすが　不愧是、果然 じっさいに　実際に "},{"id":3,"href":"/docs/archive/Nihongo/36%E8%AA%B2/","title":"36課","section":"Nihongo","content":" 単語 # こうじょう　工場\nえんとつ　煙突\nグラウンド　ground\nおくじょう　屋上　屋顶\n屋上カフェ　cafe\nたこ　凧　风筝\nタープ　tape　磁带\nどくしょ　読書\nしんせい　申請　友達申請を送りました。\nかんさいべん　関西弁\n日本文化　日本文化に興味がある。\nはかりうり　量り売り　秤斤卖\nご主人／旦那さん\n主人／旦那／夫（おっと）　自分の\nもちあるく　持ち歩く　携带　たくさんの現金を持ち歩くのは危険です。\nくりかえす　繰り返す　反复　もう一度繰り返してください。\nさわぐ　騒ぐ　吵嚷\nまにあう　間に合う　来得及　電車に間に合わなかった。\nねむる　眠る　睡着　彼は寝ています。　彼は眠っています。\nなく　鳴く　叫、鸣、啼（动物）　声\n朝起きると、鳥が鳴いているのを聞きました。 なる　鳴る　鸣响、响起（物体）　音\nベルが鳴ったら、すぐ席に戻ってください。 ベル　Bell　もどる　戻る なく　泣く　哭泣\nよろこぶ　喜ぶ　喜悦（自他动词）\n就職ができて、両親は喜んでくれます。 しゅうしょく　就職　找到仕事父母很为我高兴。 やくだつ　役立つ　有用\n研究に役立つ資料。 全然役立たない。 やとう　雇う　雇佣\nふる　振る　挥动、摆动\n手を振る。 見える、聞こえる\n遠くの山が見える。 鳥の鳴き声が聞こえる。 つうじる　通じる　通过、相通\n言葉が通じない。 あげる　揚げる　放、扬起\n凧を揚げる。（たこ　凧）　放风筝 なれる　慣れる\n～に慣れる。 新しい生活に慣れました。 ぬれる　濡れる（自动）　淋湿\n雨に濡れました。 やける　焼ける　着火、燃烧\n家が焼ける。 さげる　下げる　降低、下降\n生産コストを下げる。　降低生产成本 くろうする　苦労する\n生活に苦労しました。 しゅっせきする　出席する\n文法 # 小句1て/で、小句2 # 动词て形，小句2多为心理活动或感情变化的表达。 形容词くて（で），小句2多为结果或能力的表达。 名词＋で，小句2多为不良结果。 无论小句1接续什么，小句2不能以强烈意志表达结局，如命令，禁止，劝诱。 わざわざ来てくれて、嬉しかった。 遅くなって、すみません。 そんな難しい試験に合格して、よかったですね。 最初言葉が通じなくて、とても困ります。 恋人にずっと会うことができなくて、悲しいです。 会議があって、行くことができません。 森さんは頭が痛くて、会社を休みました。 説明が上手で、よくわかりました。 使い方が簡単で、子供でも操作することができる。（そうさ　操作） うるさくて、テレビの音が聞こえません。 雨で、家でテレビを見るしかないです。 病気で、学校を休みました。 仕事で、おととい駅前の喫茶店で李さんと会いました。 父が大阪の出身で、いつも関西弁で話します。 助词　に　用途 # ～は　动词の/名词　＋　に　使います。 この写真は何に使いますか。 パスポートの申請に使います。 パスポートを申請するのに使います。 その紙はプレゼントを包むのに使います。 助词　に　评价标准 # ～は　动词の/名词　＋　に　评价类标准。 アニメは日本語の勉強に役立ちます。 アニメは日本語を勉強するのに役立ちます。 この車の修理に２時間ぐらいかかります。 この車を修理するのに２時間ぐらいかかります。 スーパーが近いので、このマンションは買い物に便利です。 早寝早起きは体にいいと思います。 この本は大人には簡単ですが、子供には難しいです。 その仕事はそんなに簡単で、僕にもできますよ。 限定　～ばかり # 名词＋ばかり　表示所列举的事务全部相同，ばかり表限定时，消极语感比较强。 動詞て＋ばかりいる　表示相同的事务いつも発生する。消极语感比较强。 彼はいつも文句ばかり言っている。　（もんく　文句）　他（一天到晚）净发牢骚。 あの人はいつも嘘ばかりつくから、あまり信じないほうがいいですよ。 いつもご迷惑ばかりかけて、すみません。 張さんは毎日お酒を飲んでばかりいます。 森さんはいつも失敗してばかりいます。 母親は朝から怒ってばかりいます。　（おこる　怒る） 食べてばかりいると、太りますよ。　（ふとり　太り） 三つだけ食べました。　只吃了三个。 三つばかり食べました。　吃了三个左右。 "},{"id":4,"href":"/docs/archive/Nihongo/35%E8%AA%B2/","title":"35課","section":"Nihongo","content":" 単語 # カタログ　商品目录 もくじ　目次　书目录 たからくじ　宝くじ　くじ（籤）　たからくじに当たる。 きく　効く　有效 いわう　祝う　入学祝い あく　空く　明日空いてる？　この部屋は空いてる？ くさる　腐る　バナナが腐ります。 みつける　見つける　仕事を見つける。 たずねる　訪ねる　友人の家を訪ねる。 たいざいする　滞在する　東京に滞在中。 さんかする　参加する　試合に参加する。 きゅうけいする　休憩する かんぱいする　乾杯する かんぜんなじゅんび　完全な準備 春になると、だんだん暖かくなる。 暖かい　あたたかい 秋になると、紅葉の葉がだんだん赤くなります。 紅葉　もみじ 赤い　あかい 文法 # ～たら、～ # 未知的假定条件：如果~，就~\n以可预见的事情或状态作条件，后续不能使用过去式，表示预计的情况\n满足前项条件，出现了后项预料之外的结果，后续使用存续状态或过去式，用法与と相同\n与「と」不同的是，「たら」的后項可以接意志，请求，命令等表达。\n雨だったら　雨でなかったら 雨でしたら　雨でありませんでしたら もし宝くじに当たったら、新しい家を買うつもりです。 要是中彩票了，我打算买个新房子。 今月暇でなかったら、来なくてもいいです。 天気が良かったら、ハイキングに行きます。 天气好的话，我就去郊游。 来週の金曜日、帰国する。帰国したら、すぐ君に電話する。　下周五，我要回国。回国后，马上就给你打电话。 コピー機を使い終わったら、電源を切ってください。　用完打印机，请把电源关掉。 うちに帰ると／帰ったら、電気がまだついている。　回到家后，发现灯还亮着呢。 うちに着くと／着いたら、友達から手紙が来た。　到家了，发现有一封来信。 ～ても、～ # 即使~，也~ 休みの日でも、忙しいです。 簡単な単語でも、なかなか覚えることができない。　即使是简单的单词也怎么都记不住。 日本語が上手ではなくても、この仕事はできますよ。 私はスペイン語を知らないので、見ても分かりません。 この言葉はいくら調べても、たぶん辞書にはないでしょう。　这个说法无论怎么查，字典里可能都不会有吧。（いくら～ても、～。　不管怎样，无论怎样都~） 必要ではないものがいくら安くても、買いません。 これは小学生でもできる計算です。 よく効く薬でも、たくさん飲むと体によくありません。 日本人でも知らない日本語。 ～だけ、～ # これは全部、他のはない。\nうちのクラスには男が3人だけいます。\nこれだけ面白くないと思います。\n休みは今日だけです。\n好きな人は君だけです。\nうちの会社で、学歴が高い人は李さんだけではないです。　（がくれき　学歴）\nこの頃、今日だけ（は）雨です。　这些天，只有今天下雨。\nうちの会社にわたしだけ（が）中国人です。\n（は）、（が）、（を）　なくてもいい 君　だけに／にだけ　会いたいです。\nこの事は君　だけと／とだけ　相談します。\nと、で、に　なくではできません。 ～しか、～ # 数量词/名词+しか+否定表达，除了前项，其他都不是，仅仅、只 わたしは水しか飲みません。 わたしは水だけ飲みます。 会議室には李さんだけいます。 会議室には李さんしかいません。 こうなったら、最後までやるしかないです。 そんなにいやならやめるしかないです。 この病気は手術しかないです。　（しゅじゅつ　手術） 冷蔵庫の中には野菜しかないです。 私は生卵だけ食べません。 私は生卵しか食べません。 "},{"id":5,"href":"/posts/TaaS/","title":"Reading: Timestamp as a Service, not an Oracle","section":"Blog","content":"Most distributed databases rely on a timestamp oracle to order events. In our case, we have a service called TimeOracle that uses a distributed lock to ensure monotonic timestamps. However, it can’t avoid brief periods of unavailability. TaaS proposes a timestamp service that could serve as a perfect replacement for TimeOracle. I became curious about how to maintain monotonic timestamps while avoiding unavailability—so let’s dive into it.\nPaper Link # Timestamp as a Service, not an Oracle\nTerminology # session: A session starts when the client requests a timestamp, and ends when all the servers reply. \\(N\\) : The number of servers. It provides # Availability that the timestamps are always computable, provided any majority of the server clocks being observable. Correctness that all the computed timestamps must increase monotonically over time, even if some clocks become unobservable. Algorithm # A client starts a session by broadcasting a timestamp (⊥) to all servers. In basic scenarios, ⊥ can be looked as negative infinity.\nEach server has a persistent timestamp \\(c\\) . When it receives a request, it increments its timestamp and returns the new value (noted as \\(c \\oplus t\\) ) to the client. The new value can be \\(max(c, ⊥) + 1\\) . This means that the client always knows that before it requested to the server, the server had a timestamp less than the timestamp it just received from the server.\nAfter the session is completed, the client uses the \\(M^{th}\\) ‑smallest timestamp from the replies, where \\(M \\lt N\\) and \\(M\\) is shared by all clients. (The best practice says that \\(M\\) should be the smallest majoriy, even though \\(M\\) can be anything between 1 and \\(N\\) )\nDefinition\nThe timestamp for session \\(T\\) is guaranteed larger than the timestamp for any session \\(S\\) that ended before \\(T\\) began.\nAssumes no server failures or message loss, here comes the basic correctness proof.\nbasic correctness proof\nThe \\(M^{th}\\) ‑smallest response in \\(S \\le\\) the \\(M^{th}\\) ‑smallest server state at the end of \\(S\\) . (Servers\u0026rsquo; timestamps increase monotonically.) The \\(M^{th}\\) ‑smallest server state at the end of \\(S \\le\\) the \\(M^{th}\\) ‑smallest server state at the start of \\(T\\) . (Monotonicity, and \\(S\\) ends before \\(T\\) starts.) The \\(M^{th}\\) ‑smallest server state at the start of \\(T \\lt\\) the \\(M^{th}\\) ‑smallest response in \\(T\\) . (The client makes all the servers increment their timestamps during \\(T\\) .) By transitivity, the \\(M^{th}\\) ‑smallest response \\(\\lt\\) the \\(M^{th}\\) ‑smallest response in \\(T\\) . If servers can crash, then things become a bit more complicated. Let\u0026rsquo;s look back at the definition. There are two facts that the definition above depends on:\n\\(t \\gt M^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session started \\(t \\le M^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session ends Let\u0026rsquo;s look at the example from the paper, where M is 2: In session δ, the client remember that it got the timestamp 5 in some past session from Server X. Therefore it can pick 5 because the clients knows:\n\\(5 \\gt 2^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session started: The client heard Servers Y and Z respond with timestamps 4 and 5, so their previous timestamps were less than 5. \\(5 \\le 2^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session ends: The client knows Servers X and Z now have timestamps at least 5. Depends on these two facts, the definition is true. However in session ε, the client doesn\u0026rsquo;t know the second-smallest timestamp. Thus, both of these scenarios may be true:\nX is 7, then the second‑smallest would be 6. X is 5.5, then second‑smallest would be 5.5. How to solve this problem? The client continues this session, and sends 6 to Server Y.\nWhy 6? Because it thinks 6 might be the second-smallest timestamp. Why Server Y? It got 5 from the Server Y, so Server Y might have the timestamp less than 6. Now the Server Y updates its own timestamp to at least 6. Let\u0026rsquo;s assume it is 7, so the client has 6 from Z, 7 from Y. Then:\n\\(6 \\gt 2^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session started: The first trip the client received from Y and Z with 5 and 6, so they started session with less than 6. \\(6 \\le 2^{th}\\) ‑smallest of all servers\u0026rsquo; timestamps when the session ends: The second trip the client reveived from Y and Z with 7 and 6, they ended with at least 6. With one more trip, the client achieved certainty.\nHow to keep unique timestamps?\nAnnotate each timestamp with its sending server’s identifier. Timestamps of the same counter (higher bits) are ordered by their server identifers (lower bits), e.g., \\( 1.x \\lt 1.y \\lt 1.z \\) Miscellaneous # Why TaaS instead of TrueTime? TaaS is designed to solve the problem within one data center. In contrast, TrueTime was intended for use across multiple data centers. Referencce # Review: Timestamp as a Service, not an Oracle "},{"id":6,"href":"/posts/robinhood/","title":"Robin Hood Hashing","section":"Blog","content":"I found an interesting story about Robin Hood when I first learned about Robin Hood Hashing(and there is another RobinHood that provides financial services, which I don\u0026rsquo;t believe is a coincidence). Robin Hood was a bandit, but he was a good guy who robbed the rich in order to give to the poor. And that implies the basic idea behind Robin Hood Hashing.\nBasically, hash table has two different ways to store the values. The one is closed adressing(e.g., separate chaining) and the other is open addressing. Robin Hood Hashing is a variation of open addressing in hash tables. It aims to minimize the variance in probe sequence lengths by ensuring that elements with longer probe sequences \u0026ldquo;steal\u0026rdquo; slots from elements with shorter probe sequences. This approach helps balance the load and reduces clustering, improving overall performance.\nAlgorithm # Probe Sequence Length # Above we said robin hood hashing aims to minimize the probe sequence lengths. How we calculate the length? If we can found value just by looking in the bucket to which they hash, then we say the psl of this slot is 0. But if we need move on next bucket to find the slot, then the psl of this slot is 1. There is where \u0026ldquo;robbed the rich in order to give to the poor\u0026rdquo; happens. There might be a hugo difference psl among those values. What we want to do is balance them.\nInsertion # b = {}; void insert(v) { p = hash(v) % b.length; slot = {v, vpsl = 0} while (b[p] != null) { if (slot.vpsl \u0026gt; b[p].psl) { swap(v, b[p]) } p = (p + 1) % b.length slot.vpsl = slot.vpsl + 1; } b[p] = slot } Removal # Robin hood hashing use backward shifting to remove a slot. It works as follows:\nclear the slot which holding the key. shifting the keys in the following slots back one step to fill the gap until a key is encoutered with PSL 0 or an empty slot is found. b = {}; void remove(v) { p = hash(v) % b.length; b[p] = null; n = (p + 1) % b.length; while (b[n] != null and b[n].psl != 0) { b[p] = b[n]; b[n] = null; p = n; } } "},{"id":7,"href":"/posts/FalseSharing/","title":"False Sharing","section":"Blog","content":"Recently, we want to enable mavx2 in our project, but that results in core dumps in our test suites. Using gdb to investigate the issue, it was found that all the core dumps occur due to unaligned access in Folly. Upon reviewing the assembly code produced by the compiler, it was found that Clang generates vmovaps, which stands for Move Aligned Packed Single-Precision Floating-Point Values. This instuction needs a 16byte aligned variable. In contrast, using GCC appears to resolve the issue, as no core dumps occur(Apparently, that is incorrect since Clang has used more aggressive optimization). A inappropriate approach to fixing the issue is to remove alignas from the Folly. But why does Folly use alignas despite it will employ techniques like placement new which can violate memory alignment? What will happen if we simply remove alignas? The most important reason may be to prevent False Sharing.\nDefinition # False sharing is a performance issue that arises in multithreaded programs when multiple threads access different variables located on the same cache line. Although the threads operate on separate data, the cache coherence protocol treats the entire cache line as a single unit. This results in unnecessary invalidations and cache misses, degrading performance. So Folly uses alignas to separate each variable into different cachelines, which can avoid accessing the same cacheline when accessing different variables.\nSolution # We found two issues related to unaligned access on Github. However, it seems that Folly will not resolve this issue in the near future. Therefore, we have to make tradeoffs between enabling avx and removing alignas. Finally we decided to remove alignas.\n"},{"id":8,"href":"/posts/2024/","title":"2024","section":"Blog","content":" 旅行 # 今年去了挺多地方：武汉、京都、大阪、奈良，以及北海道。没想到今年会去两次日本，第一次是为了京吹巡礼（巡礼回来后被京吹背刺），第二次则是和小伙伴们去北海道旅游（感谢 fdl 辛苦开车）。\n到达北海道的第一反应是：原来这就是雪国，从天空往下望去，一片白茫茫。言语没有办法形容当时心中的震撼，可能是南方人第一次见到这么多的雪，造成了不小的冲击： 参观了北大（北海道大学），遇见了一个树洞里的雪人： 在旭川看到了 tomori： 夜爬天狗山（其实也就 18 点），缆车由于大风大雪已经停运了，爬到一半太滑无法站立只得下山，至少在天狗山留下了一段痕迹： 登别地狱谷，漫山的乌鸦以及烟雾，同伴都说很臭，但是我疑似阳了基本没闻到啥味： 由于没有买到函馆的车票，函馆行程被迫取消，但是临时起意决定去洞爷湖，收获到了不错的风景： 再放一波图片，拍到人生照片了家人们： 工作 # 这部分要写啥呢？明明占用了我 2024 的绝大部分时间，但却没有什么东西可以写的，先这样吧。\n最后 # 本来没打算写年终总结，去年开始写博客时留下的 flag 也没有实现，最后我只能假装什么都没有发生，灰溜溜的将其删掉。\n用一句话来概括我的 2024，我会说是充满了痛苦以及迷茫。\n10 月份开始感觉失眠变得更加严重了，于是终于下定决心去看了医生。吃了近一个月的安眠药，安眠药的效果就是让人可以睡觉，但是睡眠质量并不好。副作用也很明显，一到下午就昏昏欲睡，眼睛睁不开。停药反应非常严重，基本上是停药后接下来的一个星期都没办法好好睡觉，尤其是第一个晚上，完全无法入睡。到最后也没有治好失眠，起床的时候总是会头痛。由于缺少睡眠，感觉记忆力变得越来越差了。写到这里时突然想起在机场时和同伴说起背护照号的事情，于是赶紧背了一下来看看自己有没有忘记。\n12 月的旅行并没有我想象中的那么开心，出发前充满了期待，出发之后却只是一种解脱的感觉，并没有真正的享受旅行的乐趣。上班上的\n顺便一提，今年开始学习吹小号了。但是最近感觉越练越差，还是在纠结嘴形。高音倒是可以吹上去，但是吹曲子的时候就完全不行了。希望可以吹得更好，うまくなりたい。\n即使是现在，我也没有办法摆脱那种迷茫空虚的感觉。像是无头苍蝇一样，没有什么目标的生活。而对我来说，没有目标的生活，就像是一场没有终点的马拉松，实在是太辛苦了。\n现在是 2025 年 1 月 1 日，接下来希望自己可以摆脱痛苦，摆脱迷茫。有时间的话多写一点技术博客（去年一时兴起写的乱七八糟）。考虑一下是不是要去健身（会有时间吗）。\nFirst Love 里有一句歌词：明日の今頃には、あなたはどこにいるんだろう。而在北海道的时候和同伴互相寄了明信片，寄给我的明信片里则写了魔改的一句：来年の今頃には、あなたはどこにいるんだろう。我无法知道明年的这个时候我会在哪里，但是我仍然希望明年的这个时候会越来越好。\nBTW，我现在就要看颂乐人偶！！！\n"},{"id":9,"href":"/posts/ConsistentHash/","title":"Consistent Hashing","section":"Blog","content":" Paper Link # Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web\nSomething about hash # Credited to F14.\nSome hash functions distribute information evenly across all their bits — any change to the input causes an avalanche of changes to the hash code. Ideally, any one-bit change in the input is expected to change about half the bits of the output. These hash functions can be mapped onto a power-of-two range by just zeroing the top bits. For example, we might map hash codes across 32 chunks by zeroing all but the bottom five bits.\nAt the other end of the spectrum are hash functions like std::hash for integral types, which is often the identity function. It meets the C++ standard’s requirements for hash quality (hash codes are very unlikely to be equal unless the inputs are also equal), but it doesn’t spread information at all. If we just took the bottom five bits, for example, then we would experience a large number of collisions if all the integer keys were multiples of 32. If the hash function doesn’t distribute information, then F14 must postprocess the hash code with a bit mixer.\nIntroduction # The paper contains a lot of mathematics, but we try to focus on definition and implementation of the consistent hashing. We will skip the mathematical details and theorem proofs, and only concentrate on the core contributions of the paper.\nDefinitions # Balance: literally balance, meaning that hash function could generate a hash code with an even distribtion. Monotonicity: this property says that if items are initially assigned to a set of buckets \\(\\mathcal{V}_1\\) and then some new buckets are added to form \\(\\mathcal{V}_2\\) , then an item may move from an old bucket to a new bucket, but not from one old bucket to another old bucket. Spread: For example, there is a set of clients, and each clients may have different sight of servers. The spread means the same item will be assigned to a same server with high probability. Load: The load property is similar to spread. It just explain the same thing from a different side. Implementation # Implementation is simple, proofs are hard. If you want to learn about the proofs, you should read the paper. Let\u0026rsquo;s get into the implementation here.\nLet\u0026rsquo;s say we have two functions \\(\\mathcal{r}_\\mathcal{I}\\) and \\(\\mathcal{r}_\\mathcal{B}\\) (we often use MurmurHash in the industry). The function \\(\\mathcal{r}_\\mathcal{B}\\) maps buckets randomly to the unit interval, and \\(\\mathcal{r}_\\mathcal{I}\\) does the same for items. The consistent hashing is defined to be the function which maps the item \\(i\\) to the bucket “closest” to \\(i\\) . In the industry, we usually map the same bucket to multi-nodes by concatenating a suffix to the bucket.\nThoughts # What is the most innovative part of consistent hashing? I would say the main idea of the consistent hashing is to use mapping functions to map both bucket and item to the unit interval. This approach ensures that when the buckets changes, most items will not move to the changed bucket. Can we make any improvements on consistent hashing? Yes, Google has proposed a paper(jump consistent hash) which optimizes the performance for lookups. "},{"id":10,"href":"/posts/TheCongnitiveLoadOfC++/","title":"The congnitive load of C++","section":"Blog","content":" std::shared_ptr # Consider the following code below:\nstruct Base { virtual ~Base() {} }; struct Derived : public Base { virtual ~Derived() {} }; struct Wrapper { Wrapper(const std::shared_ptr\u0026lt;Base\u0026gt;\u0026amp;a) : a(a) {} const std::shared_ptr\u0026lt;Base\u0026gt;\u0026amp; a; }; Wrapper do_something(const std::shared_ptr\u0026lt;Base\u0026gt;\u0026amp; a [[clang::lifetimebound]]) { Wrapper w(a); return w; } int main() { std::shared_ptr\u0026lt;Derived\u0026gt; t = std::make_shared\u0026lt;Derived\u0026gt;(); auto i = do_something(t); std::printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;t); std::printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;(i.a)); } Everythings seems OK but if we use the annotation [[clang::lifetimebound]] from clang, we could get the following warning:\nwarning: temporary whose address is used as value of local variable \u0026lsquo;i\u0026rsquo; will be destroyed at the end of the full-expression [-Wdangling]\nBut if we just ignore the warning and run the program, we may get the output like this:\n0x7ffff09985d0 0x7ffff09985b8 So here comes some questions: What happened here? Where is the \u0026ldquo;temporary\u0026rdquo; exactly as? And why are the addresses of t and i.a different?\nI believe we all know that if we use a temporary reference as the parameter, when the object is destroyed, the reference would turn into a dangling pointer. However, t wasn\u0026rsquo;t destoryed. Nonetheless, compiler gives us a warning that we take a temporary variable (which was t) which was destoryed at the end of the full-expression. That\u0026rsquo;s weird, because t was exactly there and wasn\u0026rsquo;t destoryed! Some people may say that\u0026rsquo;s a compiler bug. Well, maybe the warning was strange, but it did generate a correct warning.\nSo, let\u0026rsquo;s take a see at constructor of std::shared_ptr from cppreference.\nshared_ptr( const shared_ptr\u0026amp; r ) noexcept; template\u0026lt; class Y \u0026gt; shared_ptr( const shared_ptr\u0026lt;Y\u0026gt;\u0026amp; r ) noexcept; Constructs a shared_ptr which shares ownership of the object managed by r. If r manages no object, *this manages no object either. The template overload doesn\u0026rsquo;t participate in overload resolution if Y* is not implicitly convertible to(until C++17)compatible with(since C++17) T*.\nAs we know, Base and Derived are covariant and raw pointers to them will act accordingly. But shared_ptr and shared_ptr are not covariant even if Y is derived from T. So as the cppreference says, if Y* is implicitly convertible to T*, then it will construct a shared_ptr if you pass a shared_ptr to function do_something. At the end of the expression auto i = do_something(t);, the shared_ptr was destoryed. What you assign to Wrapper in do_something will become a dangling pointer. And that is where the temporary variable comes from.\nHowever, the above scenario does not occur with unique_ptr. (What can I say)\nstd::unique_ptr\u0026lt;Derived\u0026gt; is implicitly convertible to std::unique_ptr\u0026lt;Base\u0026gt; through the overload (6) (because both the managed pointer and std::default_delete are implicitly convertible).\nHmm. Keep updating\u0026hellip;\n"},{"id":11,"href":"/posts/japan/","title":"日本旅行","section":"Blog","content":" Intro # 在和同学聊天的时候提到日本旅游，同学让我写一个攻略（暂且认为是攻略吧）参考一下，因此便有了这篇博客。因为是随手写的，可能有不完善的地方，有其他问题的话可以通过邮件和我联系。\n住宿 # 住宿的话基本就是两个选择：民宿或者酒店。我和同学一起去的时候，选择民宿或者酒店的参考标准是停留时长，在一些城市停留的时间比较久则预定民宿，一些城市停留的时间比较短则预定酒店。我自己一个人旅游的时候因为安全考虑以及性价比，选择了预定酒店。\n如果人比较多且时间较长的话，民宿的性价比更高，有时候房东可能会提供一些交通工具（自行车），这个可以在 airbnb 上看介绍或者和房东交流。人少的话预定民宿的性价比就比较低了。酒店的平均价格需要看时间以及地段，我自己单人的话平均每晚在 RMB 400-500，地段是还比较好的。另外预定酒店时最好是在 Google Maps 上查一下评价，搜一下关键词 bed bugs（最近（2024-6）日本的床虫好像有点泛滥），防止被咬引起过敏等等。\n交通 # 交通基本上都是使用公共交通，极少的情况下需要打车。打车比较简单，下载一个 Uber 就可以了，下面主要讲一下公共交通。\n交通卡 # 如果是苹果手机的话可以直接在钱包上开通一张西瓜卡（suica），支持银联充值，非常方便。除了一般的电车公车之外，便利店和贩卖机也都可以使用交通卡进行支付。如果不是苹果手机的话可以在 JR（Japan Railways） 的机器（一般落地之后在机场就可以找到）上购买游客专用的西瓜卡，游客专用卡是有有效期的，离开日本前记得把余额用完。除了西瓜卡之外，实体卡还有别的选择，基本上都可以在日本全国使用，常见的有以下几种：pasmo、icoca。另外，除了在手机上开通的公交卡可以使用手机支付充值之外（苹果目前就是使用苹果支付），其他的实体卡都只支持现金充值。这点还是挺重要的，特别是仅使用实体卡旅行的需要注意一下。\n地图 # 推荐使用 Google Maps，按照上面的导航走不会有问题的。需要注意的是有一种换乘是无需下车的，Maps 上会有相应的提示，看到这个不需要惊讶。\n支付 # 我自己的支付方式有四种：现金、VISA、电子支付（支付宝、微信）、公交卡。电子支付几乎很少用到，主要是使用现金以及 VISA。不过电子支付在日本的主要城市以及主要景点都是可以使用的。推荐准备足够的现金，因为有些店是 cash only 的。另外的支付方式都有不能用的风险。\n就我个人而言，7 天的行程最多需要 5 万日元（时间点是 2024-06，基本使用现金的情况下）。我是购物比较少的情况，基本都是吃吃喝喝还有充值公交卡。有大宗的消费购物可以直接使用 VISA，不需要使用现金（一般这种店都会支持信用卡）。\n景点 # 景点就是见仁见智了，我也仅仅去过 5 个地方：东京、富士山、京都、大阪、奈良。我去过的地方中，按照个人喜好排序的话如下：京都 \u0026gt; 富士山 \u0026gt; 东京 \u0026gt; 大阪 \u0026gt; 奈良。京都的文化氛围很浓，可以比较沉浸式的感受日本文化；而富士山则是风景比较好；东京大阪都属于大城市，我感觉差不多，东京排在前边单纯是因为东京周围的神奈川县和千叶县比较有意思；奈良如果对佛教文化感兴趣的话可以去看一看，我个人是觉得没什么意思，奈良的鹿比较多，味比较大，需要做好心理准备。\n最后 # 随便放点照片吧，主要是巡礼的照片，只能说看动画的人是这样的。 "},{"id":12,"href":"/posts/Percolator/","title":"Percolator","section":"Blog","content":" 论文链接 # Paper: Large-scale Incremental Processing Using Distributed Transactions and Notifications\n算法描述 # BigTable 提供了单行的事务操作，但是有些事务是需要多行操作的，Percolator 解决的就是在 BigTable 上的多行事务操作。\nPercolator 实现的分布式事务依赖于三个实体： Percolator worker、TSO（timestamp oracle）、BigTable。TSO 是一个全局严格递增的时间戳服务。\nPercolator 存储一行数据时，会在 BigTable 存储多列数据：\ndata 列： 存储 value lock 列： 存储用于分布式事务的锁信息 write 列： 存储用于分布式事务的提交时间（commit_timestamp） Transaction: Write # Percolator 的分布式写事务是由两阶段提交实现的。一个写事务包含了多个写操作，事务开启时，Percolator 会从 TSO 获得一个 ts 作为事务的开始时间。包含两个阶段。\nPreWrite阶段\n在所有的写操作中随机选取一个作为 primary，其他的写操作作为 secondary。首先操作 primary。 进行冲突检测。 如果发现 write 列存在 ts \u0026gt;= start_ts，说明其他事务在当前事务开始之后提交了。说明两个事务并发写冲突，需要 abort 当前的事务。 如果在任何 ts 上发现 lock 列有数据，说明其他事务正在修改数据，仍然 abort 当前事务。也可能是另一个事务崩溃失败，需要故障恢复。 锁定和写入。对于每一行每一列要写入的数据，先将其锁定（primary 写 lock 列，secondary 的 lock 列写入指向 primary），然后写入到 data 列中。 Commit阶段\n从 TSO 获得一个 ts 作为 commit_ts。 提交 primary，如果失败则 abort。 检查 primary 上的 lock 信息是否还在，不在则 abort（其他事务认为当前事务失败，清理掉 lock）。 以 commit_ts 为 timestamp，写入 write 列，value 为 start_ts。清理 lock 列。此时为 commit point，一旦完成此步骤则视为事务成功。在此之前出错都 abort 回滚。 提交成功后给 Percolator 返回成功，secondary 异步写入，即使失败也可以通过 primary 的数据状态来判断 secondary 的结果。 Transaction: Read # 在 Percolator 中的事务隔离级别是 Snapshot Isolation。写事物主要负责清理锁。\n一些细节：\n让 pre-write 阶段先于（happens-before）获取 commit_ts。所以在 commit_ts 之后，prewrite 的数据必然被锁定了。 如果读取时，发现当前数据已被锁定（锁定意味着其他写事务正在执行），则等待并重试。当然也有可能另一个事务已经崩溃。 缺点 # Percolator 基于 BigTable 单行事务实现的分布式事务，其实是一个乐观事务模型。只有在事务提交时，才会检测写-写冲突。Percolator 事务模型的优点在于原理简单方便理解，不再需要一个中心化的单独 Coordinator，而是把 Coordinator 角色的职责进行细分，把能持久化的部分交给 BigTable 处理，后续也不再依赖 Client 的恢复。但它的缺点也是显而易见的：\nClient 和 BigTable 之间的 RPC、BigTable 和 ChunkServer 之间的RPC都会比较耗费网络资源； TSO 是一个中心化的点。并发事务很多的时候，会占用很多内存； 并发大事务可能会频繁冲突，而重试有可能会导致雪崩效应（这时候就用悲观事务模型会更好）； 懒处理事务 crash 导致一个事务的延迟可能会比较高； 依靠读操作清理锁，如果清理不及时，会增加其他正常事务写冲突的概率； 考虑另一个场景：有一个大事务和很多小事务，且它们的热点overlap，那么大事务可能受小事务的影响进入饥饿状态（即很长时间内无法执行）。 "},{"id":13,"href":"/posts/Spanner/","title":"Spanner","section":"Blog","content":" Terminology # External consistency if a transaction \\(T_1\\) commits before another transaction \\(T_2\\) starts, then \\(T_1\\) ’s commit timestamp is smaller than \\(T_2\\) ’s. What\u0026rsquo;s Special # Cross datacenter. TrueTime API. Provides external consistency at global scale. How it works? # Structure # Zone: zone is the rough analog of a deployment of Bigtable servers. zonemaster: assigns data to spannerserver. spanserver: serve data to client. location proxy: client uses it to locate the spannerserver. universemaster: a console that displays status information about all the zones for interactive debugging. placement driver: handles automated movement of data across zones on the timescale of minutes. Spanserver # Transaction # Each transaction will be assigned a timestamp to preserves lineaizability.\nRead # For read-only transaction, Paxos group\u0026rsquo;s leader assigns \\(s_{read}\\) . If read happens on single-site, Spanner just assigns LastTS() to \\(s_{read}\\) , where LastTS() is the timestamp of the last committed write at a Paxos group. For read happens on multi-Paxos groups, Spanner chose a simple choice. It just has its reads execute at \\(s_{read} = TT.now().latest\\) (which may wait for safe time to advance).\nWhat is safe time? - safe time is to preserve lineaizability. A replica can satisfy a read at a timestamp \\(t\\) if \\(t \\le t_{safe}\\) . Snapshot read is much easier than RO. It can execute at any replicas that are sufficiently up-to-date.\nWhat about Read-Write Transactions?\nDirectory # A directory is the unit of data placement, which is a set of contiguous keys that share a common prefix. When data is moved between Paxos groups, it is moved directory by directory. Paxos group consists of tablets. Each spanserver implements a single Paxos state machine on top of each tablet.\nHow to move directory? By using Movedir. It will move data in backgroud, and start a transaction to move changed datas. some information: https://www.scs.stanford.edu/17au-cs244b/notes/spanner.txt https://quizlet.com/blog/quizlet-cloud-spanner\nShortly of SSTable # It is self-describing and therefore highly redundant, and traversal of individual columns within the same locality group is particularly inefficient.\nWhy does traversing the individual columns within the same locality group cause inefficiency? What?? # In straight-up Paxos, both reads and writes go through same protocol Leader must wait another round trip to hear from quorum Why not just handle read locally at the leader (no data to replicate)? Later leader could have externalized writes, violating linearizability How do we fix Paxos to handle reads at leader? Nodes grant leader lease\u0026ndash;promise not to ack other leaders for time T Given leases from quorum, leader knows no other leaders, can read locally Assumes bounded clock drift\nTODO: https://vldb.org/pvldb/vol15/p3372-pedreira.pdf\n"},{"id":14,"href":"/posts/clash/","title":"Clash配置","section":"Blog","content":" 下载与安装 # 可以自行到仓库中下载最新版本，也可以直接复制以下命令并执行。\nwget https://github.com/Dreamacro/clash/releases/download/v0.19.0/clash-linux-amd64-v0.19.0.gz 依次执行下面命令。\ngzip -d clash-linux-amd64-v0.19.0.gz mv clash-linux-amd64-v0.19.0 /usr/bin/clash chmod +x /usr/bin/clash 将其注册为服务并开机自启 # 在/lib/systemd/system/下创建文件clash@.service：\nsudo vim /lib/systemd/system/clash@.service 将以下内容复制到clash@.service中：\n[Unit] Description=A rule based proxy in Go for %i. After=network.target [Service] Type=simple User=%i Restart=on-abort ExecStart=/usr/bin/clash [Install] WantedBy=multi-user.target 执行以下命令重新加载服务模块以及启动clash服务：\nsystemctl daemon-reload systemctl start clash@user #user为自己当前的用户名 设置开机自启动：\nsystemctl enable clash@user 配置UI # 第一次启动会在~/.config/clash下生成初始文件，现在开始配置dashboard，使得其可以在浏览器中配置节点。\ncd ~/.config/clash wget https://github.com/haishanh/yacd/archive/gh-pages.zip unzip gh-pages.zip mv yacd-gh-pages/ dashboard/ 订阅文件可以从机场官网获得，或者复制Windows下的配置文件，在其中添加上如下配置：\nsecret: xxxx external-controller: 0.0.0.0:9090 #若是云服务器记得开放端口 external-ui: dashboard 重启服务：\nsystemctl restart clash@user 此时便可以通过localhost:9090/ui/或ip:9090/ui/进行访问了。\n"}]